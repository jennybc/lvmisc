---
title: "Working with models"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Working with models}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE, comment = "#>", fig.width = 7, fig.height = 7,
  fig.align = "center"
)
```

{lvmisc} has a set of tools to work with model objects. Currently, the supported model classes are `lm` from the {stats} package and `lmerMod` from the {lme4} [package](https://CRAN.R-project.org/package=lme4). If you would like to have methods implemented to other model classes, please file an issue at https://github.com/verasls/lvmisc/issues.

The functions to work with models can be divided into three categories:

1. Model diagnostics
1. Model cross-validation
1. Model accuracy

Before starting, let's load the required packages:

```{r setup, message = FALSE}
library(lvmisc)
library(lme4)
```

# Model diagnostics

{lvmisc} has a plotting method for some common model diagnostic plots. To explore it, let's first create some example models:

```{r diagnostic_models}
m1 <- lm(disp ~ mpg + hp + cyl + mpg:cyl, mtcars)
m2 <- lmer(disp ~ mpg + (1 | cyl), mtcars)
```
The main function here is `plot_model()` and its only argument is a model object:

```{r diagnostic_plots}
plot_model(m1)
plot_model(m2)
```

By default it prints a grid of five (or four) diagnostic plots. The default plots shown are, respectively: 

- A scatterplot of the residual vs. fitted values, with a smoothing line, which is useful to show if the residuals have a non-linear pattern. In this plot, the points should be randomly distributed around the smoothing line, and the smoothing line should be approximately horizontal and around the 0 line. This plot can also be generated by the `plot_model_residual_fitted()` function.
- A scatterplot of the square root of the absolute value of the model residuals vs. the fitted values, with a smoothing line. In this plot, again you should look for a horizontal smoothing line with the points randomly distributed around it, if it's the case, you can assume the homogeneity of variance of the residuals. The `plot_model_scale_location()` function also generates this plot.
- A Q-Q plot of the standardized residuals, showing if the residuals are normally distributed. Normallity is assumed if the residuals are well aligned with the straight blue line. The function `plot_model_qq()` also builds this plot.
- A bar plot with the Cook's distance per observation. This is a useful plot to check for influential observations. A given observation is often considered to be influential in the model if its Cook's distance is higher than 1. The function `plot_model_cooks_distance()` can be used to show this plot.
- A bar plot with the variance inflation factor (VIF) per model term, which only shows if the model has 2 terms or more (you can see that in our example this plot is not built for `m2`). The VIF can be used to check the model for multicollinearity: the bar is green for a low multicollinearity, orange for moderate and red for high. The `plot_model_multicollinearity()` function can generate this plot.

# Model cross-validation

The cross-validation of a model is a way to assess how the results of a statistical model will generalize to an independent data set, but without the burden of collecting more data. At the moment, the only cross-valitation method available is the leave-one-out. Also, the only model classes supported are `lm` and `lmerMod`, but more cross-validation methods and classes will be implemented in the future.

EXPLAIN BRIEFLY HOW THE LOOCV WORKS

We will now build a linear model to demonstrate the cross-validation with the `loo_cv()` function.

```{r}
library(tibble)
# Put the rownames into a column to treat eat row as a "subject" (car) in
# the leave-one-out cross-validation
mtcars <- as_tibble(mtcars, rownames = "car")
m <- lm(disp ~ mpg, mtcars)
loo_cv(model = m, data = mtcars, id = car, keep = "used")
```
To use the `loo_cv()` function you need to specify the model you will cross-validate, the original dataset used to build it and the name of the column which identifies the subjects. You will also notice the use of the `keep` argument: it controls the columns to be shown in the output object (more details in the `loo_cv()` documentation).

The output of the cross-validation function is an object of class `lvmisc_cv`. It is simply a `tibble` with at least two columns: one containing the dependent variable actual values (`.actual`) as in the original dataset, and the other with the values predicted by the cross-validation procedure (`.predicted`). These two columns contain the data necessary to evaluate the model performance, as we will see in the next section.
